<?php

// autoload_real.php @generated by Composer

class ComposerAutoloaderInit0a614ffd835839074bc06ca0c173c1f3
{
    private static $loader;

    public static function loadClassLoader($class)
    {
        if ('Composer\Autoload\ClassLoader' === $class) {
            require __DIR__ . '/ClassLoader.php';
        }
    }

    /**
     * 整个过程其实就是将文件和路径的映射关系赋值给自动加载器类, 然后使用自动加载函数注册
     * 这样在框架中直接使用类名, 就会通过自动加载器类的 loadClass() 方法获取到其真实路径(通过命名空间到文件路径的映射),使用 include 引入.
     * 不容易理解的点 : 1.文件和路径的映射关系由谁提前生成 ? 2.通过 loadClass() 方法如何获取都真实路径, 即该函数的内部执行逻辑(比如会按顺序判断文件是否存在,不断尝试直到获取到)
     *
     * @return \Composer\Autoload\ClassLoader
     */
    public static function getLoader()
    {
        if (null !== self::$loader) {
            return self::$loader;
        }

        //注册自动家在函数, 目的是通过 new 自动引入加载器
        spl_autoload_register(array('ComposerAutoloaderInit0a614ffd835839074bc06ca0c173c1f3', 'loadClassLoader'), true, true);
        self::$loader = $loader = new \Composer\Autoload\ClassLoader();
        spl_autoload_unregister(array('ComposerAutoloaderInit0a614ffd835839074bc06ca0c173c1f3', 'loadClassLoader'));

        //判断能否使用静态加载方式
        $useStaticLoader = PHP_VERSION_ID >= 50600 && !defined('HHVM_VERSION') && ( !function_exists('zend_loader_file_encoded') || !zend_loader_file_encoded());
        if ($useStaticLoader) {
            //使用静态加载, 直接引入 autoload_static 文件, 该文件包含的类 ComposerStaticInit0a614ffd835839074bc06ca0c173c1f3 中的各类文件映射关系赋值给自动加载器
            require_once __DIR__ . '/autoload_static.php';

            //初始化自动加载器, 使用 autoload_static.php 文件中声明的类的各种路径和文件的映射关系 赋值给自动加载器
            call_user_func(\Composer\Autoload\ComposerStaticInit0a614ffd835839074bc06ca0c173c1f3::getInitializer($loader));
        } else {
            //不能使用静态加载,则使用文件形式引入,并赋值给自动加载器, 该行为和上面的一样, 都是将文件中的文件和路径的映射关系赋值给自动加载器
            $map = require __DIR__ . '/autoload_namespaces.php';
            foreach ($map as $namespace => $path) {
                $loader->set($namespace, $path);
            }

            $map = require __DIR__ . '/autoload_psr4.php';
            foreach ($map as $namespace => $path) {
                $loader->setPsr4($namespace, $path);
            }

            $classMap = require __DIR__ . '/autoload_classmap.php';
            if ($classMap) {
                $loader->addClassMap($classMap);
            }
        }

        //注册自动加载器 : 实际上就是使用 spl_autoload_register() 函数将 ClassLoader 类注册, 上面的步骤中引入的文件和路径映射关系赋值给该类的成员属性
        $loader->register(true);

        //继续根据是否可以使用静态加载来引入 autoload_files , 该文件夹内的内容是在框架启动时需要预先加载的类和函数
        if ($useStaticLoader) {
            $includeFiles = Composer\Autoload\ComposerStaticInit0a614ffd835839074bc06ca0c173c1f3::$files;
        } else {
            $includeFiles = require __DIR__ . '/autoload_files.php';
        }
        //遍历 autoload_files.php 文件中声明的路径和文件夹, 并将其引入到整个框架的全局环境里 : 这样可以在框架内的任何地方直接调用
        foreach ($includeFiles as $fileIdentifier => $file) {
            composerRequire0a614ffd835839074bc06ca0c173c1f3($fileIdentifier, $file);
        }

        return $loader;
    }
}

function composerRequire0a614ffd835839074bc06ca0c173c1f3($fileIdentifier, $file)
{
    if (empty($GLOBALS['__composer_autoload_files'][$fileIdentifier])) {
        require $file;

        $GLOBALS['__composer_autoload_files'][$fileIdentifier] = true;
    }
}
